<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[路边飞的博客]]></title>
  <link href="http://driftice.github.io/atom.xml" rel="self"/>
  <link href="http://driftice.github.io/"/>
  <updated>2013-07-23T13:33:39+08:00</updated>
  <id>http://driftice.github.io/</id>
  <author>
    <name><![CDATA[路边飞]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JVM网络移动性-笔记]]></title>
    <link href="http://driftice.github.io/blog/2013/07/22/jvm-network-mobility/"/>
    <updated>2013-07-22T16:46:00+08:00</updated>
    <id>http://driftice.github.io/blog/2013/07/22/jvm-network-mobility</id>
    <content type="html"><![CDATA[<h2>为什么需要网络移动性？</h2>

<ol>
<li><p>计算的模式发展</p>

<p> 从大型分时计算机到个人计算机集群的转变，使得计算模式从中心分时架构，变为N层C/S架构，再到分布式架构</p></li>
<li><p>一种新的软件模式</p>

<p> 逻辑跟数据 跟 运行容器 分离，可以在运行时，按需从网络获取相关的逻辑跟数据，组装成系统。其实就是B/S模式。</p>

<p> 可以解决代码的管理、升级、配置问题。</p></li>
<li><p>对网络移动性的支持</p>

<ul>
<li>动态连接。热加载class，避免一次性下载。</li>
<li>动态扩展。允许根据需要动态地扩展class集。</li>
<li>class文件格式的紧凑性</li>
<li>JAR包。减少下载次数。</li>
</ul>
</li>
<li><p>applet</p></li>
<li><p>JINI</p>

<ul>
<li>技术：　服务注册中心　+　　对象序列化　+　RMI</li>
<li>角色：　查找服务　＋　服务提供者　＋　客户机</li>
<li>协议：　网络协议（探索）　＋　对象协议（加入、查找）</li>
</ul>
</li>
<li><p>代码与对象的网络移动性是Java的<strong>设计中心</strong></p>

<p> 安全性 和 平台无关性 很多程度上为这上目标服务的。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM平台无关性-笔记]]></title>
    <link href="http://driftice.github.io/blog/2013/07/22/jvm-independence/"/>
    <updated>2013-07-22T15:17:00+08:00</updated>
    <id>http://driftice.github.io/blog/2013/07/22/jvm-independence</id>
    <content type="html"><![CDATA[<h2>为什么需要平台无关性？</h2>

<ol>
<li>设备多样化，可以不加修改地运行。</li>
<li>设备连网化，平台无关性，使得不同平台之间可以无缝地交换对象。比如，使用JINI技术</li>
<li>减少针对多平台开发的难度和工作量。</li>
</ol>


<h2>对平台无关性的支持</h2>

<ol>
<li><p>Java平台</p>

<p>  扮演着Java程序跟操作系统的缓冲角色，使得程序无需直接跟特定平台打交道</p></li>
<li><p>Java语言</p>

<p> 基本类型的值域跟行为都是自己的规范，跟平台无关</p></li>
<li><p>class文件</p>

<p> 特定于JVM的二进制格式，与平台无关，如字节序等</p></li>
<li><p>可伸缩性</p>

<p> Java平台可在不同的设备上实现，包括PC、嵌入式设备等。可根据不同的设备进行适当的裁剪，但要符合规范定义的功能子集。</p></li>
</ol>


<h2>影响平台无关性的因素</h2>

<ol>
<li><p>Java平台的部署</p>

<p> 目标平台是否有相关的Java平台实现</p></li>
<li><p>Java平台的版本</p>

<ul>
<li>各版本间的兼容性问题</li>
<li>不同的功能子集的问题</li>
<li>不同厂商针对特定平台的扩展功能问题</li>
</ul>
</li>
<li><p>本地方法</p></li>
<li>非标准运行时库</li>
<li>对JVM行为的依赖

<ul>
<li>不要依赖对象的finalization行为</li>
<li>不要依赖线程优先级</li>
</ul>
</li>
<li>对用户界面的依赖</li>
<li>Java平台的Bug
 如果目标平台集中有一个实现有Bug，会导致其他平台此功能不可使用。需要多测试。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM体系结构介绍-笔记]]></title>
    <link href="http://driftice.github.io/blog/2013/07/22/jvm-introduction/"/>
    <updated>2013-07-22T14:21:00+08:00</updated>
    <id>http://driftice.github.io/blog/2013/07/22/jvm-introduction</id>
    <content type="html"><![CDATA[<h2>为什么使用Java?</h2>

<p>网络化大潮，Java是为网络而设计。<strong>安全性</strong>、<strong>网络移动性</strong>及<strong>平台无关性</strong>都是围绕这个目标设计。</p>

<h2>体系结构</h2>

<p>四个独立但是相关的技术：</p>

<ul>
<li>Java程序设计语言</li>
<li>Java class文件格式</li>
<li>Java应用编程接口(API)</li>
<li>Java虚拟机</li>
</ul>


<h2>Java虚拟机</h2>

<p>Java虚拟机的主要任务是装载class文件，并且执行其中的代码。</p>

<p><img src="http://driftice.github.io/images/jvm_architecture_intro.png"></p>

<p><strong>不同的虚拟机，可能有不同的执行引擎</strong></p>

<ul>
<li>直接解释字节码。</li>
<li>即时编译。全部转换成本地代码）</li>
<li>自适应编译。把最频繁的10-20%代码编译成本地代码。</li>
<li>硬件芯片编译。</li>
</ul>


<p><strong>本地方法与Java方法</strong></p>

<p>本地方法(JNI)用于与操作系统打交道，是平台相关的
Java方法就是纯Java实现的方法，是平台无关的</p>

<p><strong>ClassLoader</strong></p>

<p>解决的是安全性（隔离性）与网络移动性（动态加载class).分为两类：一类是JVM的系统加载器，称为<strong>bootstrap classloader</strong>，另一个类是用户自定义的加载器</p>

<h2>Java class文件</h2>

<p>在平台无关性、网络移动性更适应网络</p>

<ol>
<li>平台无关性
 独立于底层主机的二进制形式。以<strong>以字节码</strong>的形式，避免编译时与特定系统绑定。</li>
<li>网络移动性

<ul>
<li>更紧凑的格式</li>
<li>动态连接（使用时才加载）</li>
<li>动态扩展（可动态增加class)</li>
</ul>
</li>
</ol>


<h2>Java API</h2>

<p>Java API是运行库的集合，是Java平台都要实现的必要部分，可以安全地假设可以被获取到。在需要与主机资源打交道的时候，Java可以调用Java API来实现，从而避免平台相关。</p>

<p><img src="http://driftice.github.io/images/jvm_Java_api_instr.png"></p>

<h2>Java程序设计语言</h2>

<p>一门通用语言，并不局限与网络相关的领域。其核心思想是使得程序员更有效率，程序更加健壮，而且在于为新兴的网络为中心的计算环境提供一个工具。</p>

<ul>
<li>面向对象</li>
<li>多线程</li>
<li>结构化错误处理</li>
<li>垃圾收集</li>
<li>动态连接</li>
<li>动态扩展</li>
</ul>


<p>缺点：</p>

<ol>
<li>性能的问题</li>
<li>内存管理。回收的不确定性。</li>
<li>线程调度。过于宽松的线程规范，可能导致不同平台的调度方式不同。</li>
<li>功能的最小公分母问题。这是为实现跨平台的必然困难。</li>
<li>易于反编译。这是由于为了实现动态连接性，一个类对另一个类的引用是符号引用，而不是指针或偏移量。所以，被引用的类的方法，字段等，需要详细描述。使得反编译变得容易。混淆器可以减轻这个问题。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM安全-笔记]]></title>
    <link href="http://driftice.github.io/blog/2013/07/16/jvm-security/"/>
    <updated>2013-07-16T10:21:00+08:00</updated>
    <id>http://driftice.github.io/blog/2013/07/16/jvm-security</id>
    <content type="html"><![CDATA[<h2>为什么需要安全？</h2>

<p>  安全模型使Java 成为网络环境的技术，因为它们建立了对网络移动代码安全执行的必要的可信机制。Java安全模型侧重于保护终端用户免受从网络下载的、来至于不可靠来源的、恶意程序的侵犯。而“沙箱”机制成为了这一目的的支持机制，在“沙箱”中存放不可信的 Java程序。“沙箱”对不可靠的程序的活动进行了限制，程序可以在“沙箱”的安全边界内做任何事，但是不能进行任何跨越这些边界的举动。</p>

<p>比如说, 在版本 1.0 中的沙箱对于很多不可靠的 applet 进行了如下限制：</p>

<ul>
<li>对本地硬盘的读写</li>
<li>进行任何网络连接，但是不能连接到提供这个applet 的源主机</li>
<li>创建新的进程</li>
<li>装载新的动态链接库</li>
</ul>


<h2>JVM的安全发展历史</h2>

<ol>
<li>1.0 基本沙箱。 可以严格控制代码可以做什么，不能做什么（访问控制）。</li>
<li>1.1 代码签名与认证。 基本沙箱的权限控制太过严格，导致很多正常的代码不能运行，所以引入代码签名与认证。可以针对一系列信任的代码（如JAR)提供信任策略。</li>
<li>1.2 细粒度的控制。 代码签名与认证的信任策略只能是完全信任和完全不信任，1.2引入细粒度的控制</li>
</ol>


<h2>1.0 基本沙箱</h2>

<ol>
<li><p>基本组成</p>

<ul>
<li>类加载器结构</li>
<li>Class文件检验器</li>
<li>内置于Java 虚拟机的安全特性</li>
<li>安全管理器及Java API</li>
</ul>


<p> 1.0、1.1一般需要定制安全管理器(ScurityManager)来实现定制，1.2后提供一个默认的安全管理器，这个管理器支持使用<strong>策略文件</strong>的形式来定制。</p></li>
<li><p>类加载器(ClassLoader)</p>

<p> 类加载器在以下三个方面对Java 的沙箱起着作用：</p>

<ul>
<li>它防止恶意代码去干涉善意的代码</li>
<li>它守护了被信任的类库的边界</li>
<li>它将代码归入某类（称为保护域），该类确定了代码可以进行哪些操作</li>
</ul>


<p> <strong>双亲委派</strong></p>

<p> 这是一个ClassLoader的查找过程，会在双亲中查找有没有加载相关的类，如果有，则有使用双亲中的类，如果没有，再由它加载。其中，<strong>启动类装载器</strong>跟<strong>标准扩展类装载器</strong>是JVM的系统装载器，不可更改的，而<strong>类路径装载器</strong>跟<strong>网络装载器</strong>是属于用户可定制的装载器。</p>

<p> 这样保证了基本类总由可信任的ClassLoader加载，避免一些类似Java.lang.Integer这样的类被篡改。</p>

<p> <img src="http://driftice.github.io/images/jvm_classloader_find_path.PNG"></p>

<p> <strong>命名空间</strong></p>

<p> 不同ClassLoader之间，除非有父子关系（直接或间接），不然彼此之间是不可见的。比如同样一个类<em>com.troy.Test</em>，如果由两个不同的ClassLoader加载，就是不同的两个类（虽然行为是一样的），在JVM里分属不同的<strong>运行时包</strong></p>

<p> <img src="http://driftice.github.io/images/jvm_classloader_namespace.png"></p></li>
<li><p>Class文件检验器</p>

<p> 保证装载的class文件有正确的内部结构，以及各个class文件是协调的。其安全目标就是保证程序的健壮性。毕竟，class文件不一定是由正常的编译器编译的，也有可能是黑客炮制的。</p>

<p> 总共四趟检查：</p>

<ol>
<li><p>第一趟：检查class文件的结构。</p>

<p> 就是检查class文件是否符合class文件格式，比如以0xCOFEBABE开头</p></li>
<li><p>第二趟：类型数据的语义检查</p>

<p> <strong>检查各个部分组成部分是否所属类型的实例，结构是否正确。</strong></p>

<p> 比如，检查方法描述符是否已经存储为字符器，并且符合上下文件无关文法。</p>

<p> <strong>检查是否符合特定条件</strong></p>

<p> 比如，检查一个类（除Object)外，是否都有有超类；final类没有被子类化，final方法没有被覆盖等。</p></li>
<li><p>第三趟：字节码验证。对<strong>字节码流</strong>进行数据流分析。</p>

<p> <strong>保证指序操作的合法性</strong></p>

<p> 比如，检查方法调用的参数类型是否正确，检查局部变量在初始化前不能被使用，操作数栈的总是包含正确的数值和类型等</p>

<p> <strong>安全检查</strong></p>

<p> 类似于“停机问题”，JVM也不可能写出一个可以检查出所有安全问题的程序。所以，策略是判定字节码流是否符合特定的<strong>规则集合</strong>，如果是，则判定为安全，如果不是，则视为不安全。</p></li>
<li><p>第四趟：符号引用验证。</p>

<p> 确保引用的正确性——从被验证的class文件，到被引用的class文件。因为JVM通常会使用懒加载机制，所以，这一趟通常是符号真正被引用的时候，才会进行。</p>

<p> <strong>动态连接</strong></p>

<p> 将<em>符号引号</em>解析为<em>直接引用</em>的过程。当JVM的操作码，它第一次使用了另一个类的引用时，需要进行解析：</p>

<pre><code> 1. 查找被引用的类（如果需要，就加载它）
 2. 将符号引用替代成直接引用，例如一个类的方法、字段的指针或偏移量。
</code></pre>

<p> 解析操作只有第一次引用时需要，JVM会记住相关的指针或偏移量，以后就直接使用直接引用。</p>

<p> <strong>保证二进制兼容性</strong></p>

<p> 比如：</p>

<ul>
<li>被引用的类是存在并且可以被合法加载的；</li>
<li>被引用的类的方法、字段是存在的；</li>
<li>被引用的类的方法返回的类型是合法的；</li>
<li>被引用的类的字段类型是合法的。</li>
</ul>
</li>
</ol>
</li>
<li><p>内置于Java 虚拟机的安全特性</p>

<ul>
<li>类型安全的引用转换</li>
<li>结构化的内存访问（无指针算法）</li>
<li>自动垃圾收集（不必要显式的释放被分配的内存）</li>
<li>数组边界检查</li>
<li>空引用检查</li>
</ul>
</li>
<li><p>安全管理器及Java API</p></li>
</ol>


<p>JDK文档中的安全管理器(SecurityManager)的定义：</p>

<blockquote><p>安全管理器是一个允许应用程序实现安全策略的类。它允许应用程序在执行一个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执行该操作的安全上下文中执行它。应用程序可以允许或不允许该操作。</p>

<p>SecurityManager 类包含了很多名称以单词 check 开头的方法。Java 库中的各种方法在执行某些潜在的敏感操作前可以调用这些方法。对 check 方法的典型调用如下：</p>

<pre><code>SecurityManager security = System.getSecurityManager();
if (security != null) {
    security.checkXXX(argument,  . . . );
}
</code></pre>

<p>因此，安全管理器通过抛出异常来提供阻止操作完成的机会。如果允许执行该操作，则安全管理器例程只是简单地返回，但如果不允许执行该操作，则抛出一个 SecurityException。该约定的唯一例外是 checkTopLevelWindow，它返回 boolean 值。</p></blockquote>

<p><strong>兼容问题</strong></p>

<p>在新的JVM版本已经提供了一个默认实现，SecurityManager.checkXXX是老式方式，并不建议使用，但为了向下兼容，使用了以下的委派链。事实上，真正实现安全策略的是在AccessController类</p>

<p>SecurityManager的checkXXX系列方法 （委派）—> SecurityManager.checkPermission （委派）—> AccessController.checkPermission</p>

<h2>1.1 代码签名与认证</h2>

<p>认证策略可以让用户在一个沙箱中，实现多种安全策略</p>

<ol>
<li>代码签名</li>
</ol>


<p><strong>基础知识</strong>：散列、数字指纹、公私钥、数字签名。</p>

<p>签名过程：</p>

<p><img src="http://driftice.github.io/images/jvm_code_signer_enc.png"></p>

<p>验证签名过程：</p>

<p><img src="http://driftice.github.io/images/jvm_code_signer_dec.png"></p>

<ol>
<li>认证</li>
</ol>


<p><strong>基础知识</strong>：<a href="http://lukejin.iteye.com/blog/587200">证书链</a></p>

<p>为的是解决签名过程中公私钥的发布的安全问题</p>

<h2>1.2 细精度控制</h2>

<ol>
<li><p>策略</p>

<p> 依赖于代码签名与认证的能力，可以使用一个策略描述文件，来描述不同的签名或codebase的权限。</p>

<p> <strong>策略的类结构</strong></p>

<p> <img src="http://driftice.github.io/images/jvm_policy_classes.png"></p>

<p> <strong>一个策略文件的例子</strong></p>

<p> <img src="http://driftice.github.io/images/jvm_policy_file.PNG"></p></li>
<li><p>保护域</p>

<p> 策略文件中，一段策略描述就是一个保护域。保护域描述了CodeSource和PermissionCollection，在ClassLoader加载某一个类的时候，会将这个类与一个保护域关联起来。如下：</p>

<p> <img src="http://driftice.github.io/images/jvm_protectiondomain.PNG"></p></li>
<li><p>访问控制器(AccessController)</p>

<p> <strong>原理</strong></p>

<p> AccessController是SecurityManager默认实现的真正执行类。由Accesscontroller的checkPermission（) 实现的基本算法决定了调用栈中的每个侦是否有权执行潜在不安全的操作。 每一个栈帧代表了由当前线程调用的某个方法， 每一个方法是在某
 个类中定义的, 每一个类又属于某个保护城，每个保护城包含一些权限，因此， 每个栈帧间接地和一些权限相关。</p>

<p> Accesscontroller的checkPermission（)至顶向下检查栈，只有有一个栈帧的权限不够，就会抛出异常。</p>

<p> <img src="http://driftice.github.io/images/jvm_access_controller_check_stack.PNG"></p>

<p> <strong>AccessController.implies方法</strong></p>

<p> 这是Permission的方法，用于判断一个Permission是否蕴含另一个Permission，比如/var/* => /var/temp。</p>

<p> 一般来说，是调用我们描述的Permission.implies方法，来判断当前的Permission请求是否可以通过。</p>

<p> <strong>AccessController.doPrivileged方法</strong></p>

<p> 默认情况下，AccessController是会检查所有的堆栈，隐藏的结果就是，如果一个比较低权限的类调用比较高权限的类时，只能使用比较低的权限，而自动放弃同的权限。这在很多场合下是过分严格的，比如，一个受限无访问文件权限的类，调用了一个类，而这个需要去读取一个配置文件，这样的操作是会被禁止的。</p>

<p> 所以，为了避免这个情况，提供了一个方法doPrivileged静态方法，这个静态方法的作用是<strong>截断</strong>权限检查的栈帧，如下：</p>

<p> <img src="http://driftice.github.io/images/jvm_do_privileged.PNG"></p>

<p> 这样的话，检查的栈帧就只会检查到此方法而已，如下（假设在Firend调用了以上的doPrivileged代码）：</p>

<p> <img src="http://driftice.github.io/images/jvm_do_privileged2.PNG"></p></li>
</ol>


<h1>目前的不足</h1>

<ol>
<li><p>不能应付以下两种情况：</p>

<ul>
<li>耗尽内存</li>
<li>不断开新的Thread</li>
</ul>
</li>
<li><p>没有跟系统用户集成</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何阅读一本书]]></title>
    <link href="http://driftice.github.io/blog/2013/06/24/how-to-read-a-book/"/>
    <updated>2013-06-24T15:12:00+08:00</updated>
    <id>http://driftice.github.io/blog/2013/06/24/how-to-read-a-book</id>
    <content type="html"><![CDATA[<h2>笔记</h2>

<ol>
<li><p>讨论什么是阅读，以及本书所指的阅读</p>

<ol>
<li>阅读必须是主动的阅读</li>
<li>阅读的目标应该是为了获得知识和增加理解力</li>
<li>阅读是无辅助的自我学习，让书本成为你的老师</li>
</ol>
</li>
<li><p>将阅读分为4个层次，讨论每种层次的定义、特点，以及它们间的关系。</p>

<ol>
<li>四种阅读：基础阅读、检视阅读、分析阅读、主题阅读</li>
</ol>
</li>
<li><p>什么是基础阅读，它的定义、发展与存在的问题</p>

<ol>
<li>基础阅读教育法的历史与发展趋势

<ol>
<li>从ABC教育法
 &ndash;>发音法，分析法
 &ndash;>目前百花齐放</li>
</ol>
</li>
<li>基础阅读的几个阶段，以及最终应该达到的目标

<ol>
<li>阅读准备阶段(0-6、7岁，幼稚园)</li>
<li>认字（至一年级）</li>
<li>快速建立词汇（至四年级，能够读懂交通说明、图片说明、填写简单表格等）</li>
<li>精炼与增进前三个阶段所学的技巧（至八九年级，至少在词义上，可以阅读几乎所有的读物）</li>
</ol>
</li>
<li>高等教育在超越基础阅读的教学上的问题

<ol>
<li>存在不足，导致学生阅读能力并没有继续上升</li>
<li>需要改正</li>
</ol>
</li>
<li>阅读对于开启民智、应对未来的挑战非常重要</li>
</ol>
</li>
<li><p>什么是检视阅读，它是在有限时间内阅读一本书的艺术，可以了解一本书的概貌，帮助我们确定一本书是否值得仔细读</p>

<ol>
<li>检视阅读读有两种

<ol>
<li>有系统的预读（pre-read,原书译文是说略读或粗读，但个人感觉预读这个词更准确一些）</li>
<li>粗浅的阅读</li>
</ol>
</li>
<li>有系统的预读

<ol>
<li>用快速浏览的方式阅读一本书，了解作者的重要主张，或者这到底是怎样的一本书</li>
<li>目标是要发现这个书是否真的值得仔细读，之后就算是决定了不再多花时间阅读，也可以知道跟这个书有关的事</li>
<li>如何预读的一些技术

<ol>
<li>看书名和序，了解这书的主题跟类型</li>
<li>看目录，了解这书的基本架构</li>
<li>检阅索引，找出重要词汇</li>
<li>看看出版者介绍，了解一下主旨</li>
<li>阅读主题相关的篇章，重点注意这些篇章前后的摘要（如果有的话）</li>
<li>以跳读的方式快速翻阅全书，寻找主要论点讯号，留意主题的基本脉动。尤其注意最后两三页，作者一般会在最后重新整理一下重要的观点。</li>
</ol>
</li>
</ol>
</li>
<li>粗浅的阅读（浅读）

<ol>
<li><RULE>面对一本难读的书，从头到尾先读完一遍，只注意你能理解的部分，略过不懂的部分，不要一遇到不懂的地方就停下来查询或思索。</li>
</ol>
</li>
<li>检视阅读的要点

<ol>
<li>阅读的速度。

<ol>
<li>读出速度感。检视阅读的阅读速度，理想上，不只是要读得快，而且能针对不同的目标和部分，运行不同的速度来阅读。慢不慢到不值得，快不快到有损于满足与理解。</li>
</ol>
</li>
<li>逗留与倒退。

<ol>
<li>很多人阅读时有眼光逗留与倒退的问题，这会导致速度过慢。</li>
<li>应该学会”一目十行“。</li>
<li>最简单的练习方式是，使用手指一行一行移动，速度比眼睛感觉的要快一些，强迫眼睛跟着手指移动。</li>
</ol>
</li>
<li>理解的问题

<ol>
<li>没有经过分析阅读，你就没法理解一本书</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>做一个自我要求的读者。阅读的艺术不是随手可得，需要准备好你的心态跟技术。</p>

<ol>
<li>主动的阅读。<RULE>阅读的艺术就是，根据阅读层次的不同，提出合理的问题，并尝试回答这些问题

<ol>
<li>整体来说，这本书在谈什么？主题、次主题，如何发展和分解这些主题</li>
<li>作者细部说什么，怎么说的？主要的想法、声明、论点</li>
<li>这本书说得有道理吗？是全部有道理，还是部分有道理？</li>
<li>这本书跟你有什么关系？</li>
</ol>
</li>
<li>做笔记，才会让一本书真正属于你

<ol>
<li>为什么要作笔记

<ol>
<li>笔记让你保持清醒</li>
<li>表达出来才能考验你是否真正明白</li>
<li>写出来，能帮助你记住作者的思想</li>
</ol>
</li>
<li>笔记的分类

<ol>
<li>检视阅读，结构笔记 &ndash;> 回答人问题是：这是怎么一本书？在谈什么？作者是如何整体架构的？</li>
<li>分析/主题阅读，概念笔记</li>
<li>主题阅读，辩证笔记</li>
</ol>
</li>
<li>如何作笔记

<ol>
<li>为重点画底线或画圈</li>
<li>底线下再划底线，用于强调其此为重中之重</li>
<li>空白处做星号或其他符号，再折上（或书签），用于强调书中最重要的声明或段落（不要超过十来个）</li>
<li>在空白处顺序编号，用于组织作者的陈述</li>
<li>在空白处记下其他页码（如CF p33)，用于表示参照</li>
<li>在空白处记下你的问题、答案、心得、理解、简述作者观点等。</li>
<li>书的最后页，作为个人索引页，将作者的主要观点依序记下来</li>
<li>书的前面页，记下本书的大纲</li>
</ol>
</li>
</ol>
</li>
<li>培养阅读习惯。什么是好的阅读习惯，为什么需要培养习惯，以及如何培养习惯

<ol>
<li>只有不断地依照规则练习，才能养成习惯，这才是真正掌握</li>
<li>练习阅读就像滑雪一样，需要先分解动作，逐个击破，再组合起来运用</li>
</ol>
</li>
</ol>
</li>
<li><p>什么是分析阅读，它有哪些的操作规则</p>

<ol>
<li>确定一本书的分类

<ol>
<li><RULE 1>一定要知道自己在读的是哪一类书，越早知道越好，最好在阅读之前就知道

<ol>
<li>为什么要去分类？

<ol>
<li>有时候书籍的分类并不明显，需要用心区分</li>
<li>就像不同的学科有不同的教法一样，不同的课程也有不同的学习方法，区分后方能更好的运用规则去阅读</li>
</ol>
</li>
<li>基础分类

<ol>
<li>文学类（想象文学，故事、戏剧、诗歌等）</li>
<li>论说类。一般是用于传递知识。

<ol>
<li>实用性（手册、规则等）。</li>
<li>理论性（科学、数学、哲学、社会科学、历史）。</li>
</ol>
</li>
</ol>
</li>
<li>如何区分？运行检视阅读法，注意审视书名，书名可以告诉我们很多。

<ol>
<li>如何区分理论性跟实用性？

<ol>
<li>实用是与某种有效的做法有关，不管是立即或长程的功效，而理论所关注的却是去明白或了解某件事。 实用跟理论的关系好比知识跟行动的关系。 质疑某件事的有效性是理论，而质疑任何事的目的，却是实用。</li>
<li>理论到实践，通常需要中间的操作规则。超越“知道这是怎么回事”，进而明白“如果我们想做些什么，应该怎么它”。</li>
<li>指南、学习技巧、伦理、经济、演说、道德规劝等都归为实用性</li>
<li>实用性跟作者正不正确，我们同不同意没有关系</li>
</ol>
</li>
<li>如何区分不同的理论性书籍？

<ol>
<li>历史就是纪事（ Chronotopic ），处理一些发生在特定时间，特定地点的真实事件。“纪事”这两个字就是要提醒你这一点。</li>
<li>科学则不会太在意过去的事，它所面对的是可能发生在任何时间、地点的事</li>
<li>哲学比较像科学，不像历史，追求的是一般的真理，而非发生在过去的特定事件，不管那个过去是近代或较远的年代。</li>
<li>如何区别科学与哲学？如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书。否则就是一本哲学的书。如果我们说科学家是以实验为基础，或仰赖精确的观察研究，而哲学家只是坐在摇椅上的思考者。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>透视一本书。找出一本书的基本骨架（架构）。</p>

<ol>
<li><RULE 2>使用最简短的句子（最多几句话）来描述本书的内容

<ol>
<li>能确切清楚地说出整体内容才是真正理解一本书</li>
<li>要注意： 作者经常用帮你整理出重点，但还是必须要自己表达才可以；没有唯一准确的摘要，甚至跟作者的不同也没关系，当然，一个好的摘要还是要客观上贴近事实。</li>
</ol>
</li>
<li><RULE 3>将书中重要的篇章列举出来，说明它们是如何按照顺序组成一个整体的架构

<ol>
<li>为了驾驭书的复杂性，需要捋清各个部分，并了解部分是如何组合成一个有机整体的</li>
<li>这个规则与Rule2是一体两面、互相促进</li>
<li>通用公式，如：

<ol>
<li>作者将全书分为3个部分，第一部分谈什么，第二部分谈什么，第三部分谈什么</li>
<li>第一部分又分为3个段落，第一段落为X,第二段落为Y，第三段落为Z</li>
<li>在第一部分的X段落，作者有4个重点，分别为A、B、C、D</li>
<li>等等</li>
</ol>
</li>
<li>这个通用公式只是理想情况，事实上需要根据你想读的程度来权衡。可能只需要粗浅地分析，或者只针对某一部分分析。</li>
</ol>
</li>
<li>阅读与写作是一本两面的事

<ol>
<li>为什么作者不直接列出大纲，而要读者去发挖？没有人喜欢干瘪瘪的大纲，不符合正常人的审美，情绪上不喜欢，当然也就没办法达到传达思想的作用了，所以使用艺术手法来表达自己的思想是很必要的。就好比食物，需要色香味俱全，才会有足够的吸引力。关于这点，原文的精彩论述：

<ol>
<li>尽管这些规则是一体两面，但实行起来却不相同。读者是要“发现”书中隐藏着的骨架。而作者则是以制造骨架为开始，但却想办法把骨架“隐藏”起来。他的目的是，用艺术的手法将骨架隐藏起来，或是说，在骨架上添加血肉。如果他是个好作者，就不会将一个发育不良的骨架埋藏在一堆肥肉里，同样的，也不会瘦得皮包骨，让人一眼就看穿。如果血肉匀称，也没有松弛的赘肉，那就可以看到关节，可以从身体各个部位的活动中看出其中透露的言语。</li>
<li>为什么这么说呢？为什么论说性的书，这种本来就想条理井然地传达一种知识的书，不能光是把主题纲要交待清楚便行？原因是，不仅大多数人都不会读纲要，而且对一位自我要求较高的读者来说，他并不喜欢这样的书，他会认为他可以做自己分内的事，而作者也该做他自己分内的事。还有更多的原因。对一本书来说，血肉跟骨架是一样重要的。</li>
</ol>
</li>
<li>一个作品应该有整体感，清楚明白，前后连贯。这是优秀写作的基本准则。Rule2、3是根据这条准则而来。</li>
</ol>
</li>
<li><Rule 4>找出作者要问的或想要解决的问题。找出主要问题、次要问题，和它们是如果组织、发展的。

<ol>
<li>避免”意图谬误“。

<ol>
<li>题外：新批评。<a href="http://baike.baidu.cn/view/999001.">http://baike.baidu.cn/view/999001.</a> htm

<ol>
<li>新批评提出要更关注于作品，而非作者，指出两种常见错误，一个是“意图谬误”，即对作者意图的探究为谬误。一个是”感受谬误“，即以读者情感波动弧度的大小评判作品的优劣。</li>
<li>这是对天朝赤裸裸的嘲讽啊</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>前4个规则，为分析阅读第一阶段。这4个规则的共同目标是： 完成对一本书的架构的认识</li>
</ol>
</li>
<li><p>与作者找出共通的词义</p>

<ol>
<li></li>
</ol>
</li>
<li><p>公正地判断一本书</p></li>
<li><p>赞同或反对作者</p></li>
<li><p>辅助阅读</p></li>
</ol>
</li>
<li><p>如何阅读不同的读物？要分析阅读的基础规则之上，根据不同类型的书籍的特点，需要对基础规则作相应的调整</p></li>
</ol>


<h2>本书练习</h2>

<ul>
<li><p>一句话描述</p>

<blockquote><p>   本书是一本指导手册，指导你如何超越基础阅读的层次，通过更高层次的阅读来获得知识，增加理解力。作者将更高层次的阅读划分为检视阅读、分析阅读和主题阅读，逐次讨论每个层次定义、要点和操作规则。并针对不同类型的书籍给出不同的应对策略。其次，作者还讨论了阅读的一些基本技术要点，包括做笔记、心态、阅读速度等。另外，作者反复强调了只有能够确切、清楚地解构并用自己的语言复述，才是真正的理解一本书。</p></blockquote></li>
<li><p>书的架构</p>

<ol>
<li> 这本书在讲什么？ 序言，c1,c2</li>
<li> 为什么需要本书？序言，c3-3,c3-4,c5-3</li>
<li> 阅读的基本技术要点？ c4-4,c5-1，c5-2</li>
<li> 阅读的几个层次
  基础阅读 &ndash;> c3-1，c3-2
  检视阅读 &ndash;> c4
  分析阅读 &ndash;>
  主题阅读 &ndash;></li>
<li> 针对不同的类型的书籍，如果作分析阅读</li>
</ol>
</li>
<li><p>书的问题</p>

<ol>
<li> 如何阅读一本书？

<ol>
<li> 为什么需要阅读？</li>
<li> 阅读都有哪一些层次？

<ol>
<li> 每个层次包含哪些规则，以及为什么需要这些规则，这些规则是如何组织起来的</li>
</ol>
</li>
<li> 阅读有哪一些基本技术要点

<ol>
<li> 阅读的速度</li>
<li> 做笔记</li>
<li> 心态</li>
</ol>
</li>
<li> 以上规则更多针对论说性作品的，如果是其他类型的作品，这些规则是否有效？

<ol>
<li> 是的，有效，但是需要变型</li>
<li> 那么，具体怎么变型呢？</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
